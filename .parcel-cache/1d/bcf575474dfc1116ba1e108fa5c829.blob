"use strict";
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require('./../utils.js');
var _utilsJsDefault = _parcelHelpers.interopDefault(_utilsJs);
var _helpersBuildURLJs = require('../helpers/buildURL.js');
var _helpersBuildURLJsDefault = _parcelHelpers.interopDefault(_helpersBuildURLJs);
var _InterceptorManagerJs = require('./InterceptorManager.js');
var _InterceptorManagerJsDefault = _parcelHelpers.interopDefault(_InterceptorManagerJs);
var _dispatchRequestJs = require('./dispatchRequest.js');
var _dispatchRequestJsDefault = _parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require('./mergeConfig.js');
var _mergeConfigJsDefault = _parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require('./buildFullPath.js');
var _buildFullPathJsDefault = _parcelHelpers.interopDefault(_buildFullPathJs);
var _helpersValidatorJs = require('../helpers/validator.js');
var _helpersValidatorJsDefault = _parcelHelpers.interopDefault(_helpersValidatorJs);
var _AxiosHeadersJs = require('./AxiosHeaders.js');
var _AxiosHeadersJsDefault = _parcelHelpers.interopDefault(_AxiosHeadersJs);
const validators = _helpersValidatorJsDefault.default.validators;
/**
* Create a new instance of Axios
*
* @param {Object} instanceConfig The default config for the instance
*
* @return {Axios} A new instance of Axios
*/
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new _InterceptorManagerJsDefault.default(),
      response: new _InterceptorManagerJsDefault.default()
    };
  }
  /**
  * Dispatch a request
  *
  * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
  * @param {?Object} config
  *
  * @returns {Promise} The Promise to be fulfilled
  */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || ({});
      config.url = configOrUrl;
    } else {
      config = configOrUrl || ({});
    }
    config = _mergeConfigJsDefault.default(this.defaults, config);
    const {transitional, paramsSerializer, headers} = config;
    if (transitional !== undefined) {
      _helpersValidatorJsDefault.default.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (_utilsJsDefault.default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        _helpersValidatorJsDefault.default.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();
    let contextHeaders;
    // Flatten headers
    contextHeaders = headers && _utilsJsDefault.default.merge(headers.common, headers[config.method]);
    contextHeaders && _utilsJsDefault.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
      delete headers[method];
    });
    config.headers = _AxiosHeadersJsDefault.default.concat(contextHeaders, headers);
    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequestJsDefault.default.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = _dispatchRequestJsDefault.default.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = _mergeConfigJsDefault.default(this.defaults, config);
    const fullPath = _buildFullPathJsDefault.default(config.baseURL, config.url);
    return _helpersBuildURLJsDefault.default(fullPath, config.params, config.paramsSerializer);
  }
}
// Provide aliases for supported request methods
_utilsJsDefault.default.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(_mergeConfigJsDefault.default(config || ({}), {
      method,
      url,
      data: (config || ({})).data
    }));
  };
});
_utilsJsDefault.default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(_mergeConfigJsDefault.default(config || ({}), {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
exports.default = Axios;
