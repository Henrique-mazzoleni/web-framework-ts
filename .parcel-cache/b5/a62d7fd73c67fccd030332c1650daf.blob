"use strict";
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require('../utils.js');
var _utilsJsDefault = _parcelHelpers.interopDefault(_utilsJs);
var _AxiosHeadersJs = require("./AxiosHeaders.js");
var _AxiosHeadersJsDefault = _parcelHelpers.interopDefault(_AxiosHeadersJs);
const headersToObject = thing => thing instanceof _AxiosHeadersJsDefault.default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || ({});
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (_utilsJsDefault.default.isPlainObject(target) && _utilsJsDefault.default.isPlainObject(source)) {
      return _utilsJsDefault.default.merge.call({
        caseless
      }, target, source);
    } else if (_utilsJsDefault.default.isPlainObject(source)) {
      return _utilsJsDefault.default.merge({}, source);
    } else if (_utilsJsDefault.default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!_utilsJsDefault.default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!_utilsJsDefault.default.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }
  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utilsJsDefault.default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }
  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utilsJsDefault.default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utilsJsDefault.default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }
  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if ((prop in config2)) {
      return getMergedValue(a, b);
    } else if ((prop in config1)) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  _utilsJsDefault.default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    _utilsJsDefault.default.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
exports.default = mergeConfig;
