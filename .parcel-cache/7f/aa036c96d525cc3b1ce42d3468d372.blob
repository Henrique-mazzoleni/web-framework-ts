"use strict";
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _envDataJs = require('../env/data.js');
var _coreAxiosErrorJs = require('../core/AxiosError.js');
var _coreAxiosErrorJsDefault = _parcelHelpers.interopDefault(_coreAxiosErrorJs);
const validators = {};
// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
const deprecatedWarnings = {};
/**
* Transitional option validator
*
* @param {function|boolean?} validator - set to false if the transitional option has been removed
* @param {string?} version - deprecated version / removed since version
* @param {string?} message - some message with additional info
*
* @returns {function}
*/
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _envDataJs.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }
  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _coreAxiosErrorJsDefault.default(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), _coreAxiosErrorJsDefault.default.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
/**
* Assert object's properties type
*
* @param {object} options
* @param {object} schema
* @param {boolean?} allowUnknown
*
* @returns {object}
*/
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _coreAxiosErrorJsDefault.default('options must be an object', _coreAxiosErrorJsDefault.default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _coreAxiosErrorJsDefault.default('option ' + opt + ' must be ' + result, _coreAxiosErrorJsDefault.default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _coreAxiosErrorJsDefault.default('Unknown option ' + opt, _coreAxiosErrorJsDefault.default.ERR_BAD_OPTION);
    }
  }
}
exports.default = {
  assertOptions,
  validators
};
