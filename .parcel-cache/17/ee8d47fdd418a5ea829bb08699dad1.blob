"use strict";
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require('./../utils.js');
var _utilsJsDefault = _parcelHelpers.interopDefault(_utilsJs);
var _coreSettleJs = require('./../core/settle.js');
var _coreSettleJsDefault = _parcelHelpers.interopDefault(_coreSettleJs);
var _helpersCookiesJs = require('./../helpers/cookies.js');
var _helpersCookiesJsDefault = _parcelHelpers.interopDefault(_helpersCookiesJs);
var _helpersBuildURLJs = require('./../helpers/buildURL.js');
var _helpersBuildURLJsDefault = _parcelHelpers.interopDefault(_helpersBuildURLJs);
var _coreBuildFullPathJs = require('../core/buildFullPath.js');
var _coreBuildFullPathJsDefault = _parcelHelpers.interopDefault(_coreBuildFullPathJs);
var _helpersIsURLSameOriginJs = require('./../helpers/isURLSameOrigin.js');
var _helpersIsURLSameOriginJsDefault = _parcelHelpers.interopDefault(_helpersIsURLSameOriginJs);
var _defaultsTransitionalJs = require('../defaults/transitional.js');
var _defaultsTransitionalJsDefault = _parcelHelpers.interopDefault(_defaultsTransitionalJs);
var _coreAxiosErrorJs = require('../core/AxiosError.js');
var _coreAxiosErrorJsDefault = _parcelHelpers.interopDefault(_coreAxiosErrorJs);
var _cancelCanceledErrorJs = require('../cancel/CanceledError.js');
var _cancelCanceledErrorJsDefault = _parcelHelpers.interopDefault(_cancelCanceledErrorJs);
var _helpersParseProtocolJs = require('../helpers/parseProtocol.js');
var _helpersParseProtocolJsDefault = _parcelHelpers.interopDefault(_helpersParseProtocolJs);
var _platformIndexJs = require('../platform/index.js');
var _platformIndexJsDefault = _parcelHelpers.interopDefault(_platformIndexJs);
var _coreAxiosHeadersJs = require('../core/AxiosHeaders.js');
var _coreAxiosHeadersJsDefault = _parcelHelpers.interopDefault(_coreAxiosHeadersJs);
var _helpersSpeedometerJs = require('../helpers/speedometer.js');
var _helpersSpeedometerJsDefault = _parcelHelpers.interopDefault(_helpersSpeedometerJs);
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = _helpersSpeedometerJsDefault.default(50, 250);
  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };
    data[isDownloadStream ? 'download' : 'upload'] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
exports.default = isXHRAdapterSupported && (function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = _coreAxiosHeadersJsDefault.default.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }
    if (_utilsJsDefault.default.isFormData(requestData)) {
      if (_platformIndexJsDefault.default.isStandardBrowserEnv || _platformIndexJsDefault.default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType('multipart/form-data;', false);
      }
    }
    let request = new XMLHttpRequest();
    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }
    const fullPath = _coreBuildFullPathJsDefault.default(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), _helpersBuildURLJsDefault.default(fullPath, config.params, config.paramsSerializer), true);
    // Set the request timeout in MS
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _coreAxiosHeadersJsDefault.default.from(('getAllResponseHeaders' in request) && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      _coreSettleJsDefault.default(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      // Clean up request
      request = null;
    }
    if (('onloadend' in request)) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }
    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new _coreAxiosErrorJsDefault.default('Request aborted', _coreAxiosErrorJsDefault.default.ECONNABORTED, config, request));
      // Clean up request
      request = null;
    };
    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _coreAxiosErrorJsDefault.default('Network Error', _coreAxiosErrorJsDefault.default.ERR_NETWORK, config, request));
      // Clean up request
      request = null;
    };
    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || _defaultsTransitionalJsDefault.default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new _coreAxiosErrorJsDefault.default(timeoutErrorMessage, transitional.clarifyTimeoutError ? _coreAxiosErrorJsDefault.default.ETIMEDOUT : _coreAxiosErrorJsDefault.default.ECONNABORTED, config, request));
      // Clean up request
      request = null;
    };
    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (_platformIndexJsDefault.default.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || _helpersIsURLSameOriginJsDefault.default(fullPath)) && config.xsrfCookieName && _helpersCookiesJsDefault.default.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);
    // Add headers to the request
    if (('setRequestHeader' in request)) {
      _utilsJsDefault.default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    // Add withCredentials to request if needed
    if (!_utilsJsDefault.default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }
    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }
    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _cancelCanceledErrorJsDefault.default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }
    const protocol = _helpersParseProtocolJsDefault.default(fullPath);
    if (protocol && _platformIndexJsDefault.default.protocols.indexOf(protocol) === -1) {
      reject(new _coreAxiosErrorJsDefault.default('Unsupported protocol ' + protocol + ':', _coreAxiosErrorJsDefault.default.ERR_BAD_REQUEST, config));
      return;
    }
    // Send the request
    request.send(requestData || null);
  });
});
